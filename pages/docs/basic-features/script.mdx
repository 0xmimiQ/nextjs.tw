---
描述: Next.js 使用內建的 next/script 組件來協助你最佳化載入第三方程式碼。
---

# 指令檔組件

<details>
  <summary><b>範例</b></summary>
  <ul>
    <li><a href="https://github.com/vercel/next.js/tree/canary/examples/script-component">Script Component</a></li>
    <li><a href="https://github.com/vercel/next.js/tree/canary/examples/with-google-tag-manager">Google Tag Manager</a></li>
    <li><a href="https://github.com/vercel/next.js/tree/canary/examples/with-google-analytics">Google Analytics</a></li>
    <li><a href="https://github.com/vercel/next.js/tree/canary/examples/with-facebook-pixel">Facebook Pixel</a></li>
    <li><a href="https://github.com/vercel/next.js/tree/canary/examples/with-clerk">Clerk</a></li>
    <li><a href="https://github.com/vercel/next.js/tree/canary/examples/with-segment-analytics">Segment Analytics</a></li>
  </ul>
</details>

<details>
  <summary><b>版本歷史</b></summary>

| 版本       | 更動                   |
| --------- | ------------------------- |
| `v12.2.4` | 增加 `onReady` prop        |
| `v11.0.0` | 釋出 `next/script`         |

</details>

Next.js 指令檔組件，[`next/script`](/docs/api-reference/next/script.md) 是 HTML `<script>` 元素的一個擴充功能。它允許開發者在他們的應用程式的任何位置，在 `next/head` 以外的地方設置第三方指令檔載入的優先權，節省開發者的時間外同時也提高載入效能。

```jsx
import Script from 'next/script'

export default function Home() {
  return (
    <>
      <Script src="https://www.google-analytics.com/analytics.js" />
    </>
  )
}
```

## 概述

網頁通常會使用第三方指令檔，包含不一樣形式的功能，例如：分析、廣告、客戶支援的小工具和同意聲明管理，這些可能會造成一些影響使用者和開發者體驗的問題：

- 有些第三方指令檔對於載入的效能來說是相當沈重的，並且會降低使用者體驗，特別是如果禁止運轉和延遲任何頁面內容的載入。
- 開發人員通常會難以決定在應用程式中放置第三方指令檔的位置來確保最理想的載入。

指令檔組件讓開發人員能輕鬆地在應用程式的任何位置中放置第三方指令檔的同時，也負責最佳化其載入策略。

## 應用

To add a third-party script to your application, import the `next/script` component:
若要在你的應用程式增加一個第三方指令檔，請引入 `next/script` 組件：

```jsx
import Script from 'next/script'
```

### Strategy

透過 `next/script`，你可以使用 `strategy` 屬性來決定何時載入第三方指令檔。

```jsx
<Script src="https://connect.facebook.net/en_US/sdk.js" strategy="lazyOnload" />
```

There are four different loading strategies that can be used:
總共有 4 種不同的載入策略可以使用：

- `beforeInteractive`: 在頁面互動前載入。
- `afterInteractive`: (**默認**) 在頁面即將為互動之後立即載入。
- `lazyOnload`: 在閒置期間載入。
- `worker`: (實驗性) 載入一個 web worker。

#### beforeInteractive

使用 `beforeInteractive` strategy 指令檔來進行載入的將會從伺服器中初始 HTML 被嵌入，並且在自行打包 JavaScript 開始前執行。此 strategy 應用在任何需要在頁面互動之前獲取和執行的關鍵指令檔。只會在 **\_document.js** 內執行並且是被設計來載入整個頁面所需的指令檔(例如：指令檔將會在應用程式中的任何頁面在伺服器端載入時被載入。)


`beforeInteractive` 被設計為只能在 `\_document.js` 中運作的原因是為了支持串流和 `Suspense` 功能，在 `_document` 之外的，則無法保證其時間或 `beforeInteractive` 指令檔順序。


```jsx
// In _document.js
import { Html, Head, Main, NextScript } from 'next/document'
import Script from 'next/script'

export default function Document() {
  return (
    <Html>
      <Head />
      <body>
        <Main />
        <NextScript />
        <Script
          src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js"
          strategy="beforeInteractive"
        ></Script>
      </body>
    </Html>
  )
}
```

> **注意**: `beforeInteractive` 指令檔將只會被嵌入在 HTML 文件的 `head` 無論該文件被放置在 `_document.js` 內的哪一處。

使用這個 strategy 的指令檔，應該被盡快載入的範例有：

- 機器人檢測
- Cookie 同意聲明管理工具

#### afterInteractive

Scripts that use the `afterInteractive` strategy are injected client-side and will run after Next.js hydrates the page. This strategy should be used for scripts that do not need to load as soon as possible and can be fetched and executed immediately after the page is interactive.

```jsx
<Script
  id="google-analytics"
  strategy="afterInteractive"
  dangerouslySetInnerHTML={{
    __html: `
    (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer', 'GTM-XXXXXX');
  `,
  }}
/>
```

Examples of scripts that are good candidates to load immediately after the page becomes interactive include:

- Tag managers
- Analytics

#### lazyOnload

Scripts that use the `lazyOnload` strategy are loaded late after all resources have been fetched and during idle time. This strategy should be used for background or low priority scripts that do not need to load before or immediately after a page becomes interactive.

```jsx
<Script src="https://connect.facebook.net/en_US/sdk.js" strategy="lazyOnload" />
```

Examples of scripts that do not need to load immediately and can be lazy-loaded include:

- Chat support plugins
- Social media widgets

### Off-loading Scripts To A Web Worker (試驗性)

> **Note: The `worker` strategy is not yet stable and can cause unexpected issues in your application. Use with caution.**

Scripts that use the `worker` strategy are relocated and executed in a web worker with [Partytown](https://partytown.builder.io/). This can improve the performance of your site by dedicating the main thread to the rest of your application code.

This strategy is still experimental and can only be used if the `nextScriptWorkers` flag is enabled in `next.config.js`:

```js
module.exports = {
  experimental: {
    nextScriptWorkers: true,
  },
}
```

Then, run `next` (normally `npm run dev` or `yarn dev`) and Next.js will guide you through the installation of the required packages to finish the setup:

```bash
npm run dev

# You'll see instructions like these:
#
# Please install Partytown by running:
#
#         npm install @builder.io/partytown
#
# ...
```

Once setup is complete, defining `strategy="worker"` will automatically instantiate Partytown in your application and off-load the script to a web worker.

```jsx
<Script src="https://example.com/analytics.js" strategy="worker" />
```

There are a number of trade-offs that need to be considered when loading a third-party script in a web worker. Please see Partytown's [Trade-Offs](https://partytown.builder.io/trade-offs) documentation for more information.

#### 配置

Although the `worker` strategy does not require any additional configuration to work, Partytown supports the use of a config object to modify some of its settings, including enabling `debug` mode and forwarding events and triggers.

If you would like to add additional configuration options, you can include it within the `<Head />` component used in a [custom `_document.js`](/docs/advanced-features/custom-document.md):

```jsx
import { Html, Head, Main, NextScript } from 'next/document'

export default function Document() {
  return (
    <Html>
      <Head>
        <script
          data-partytown-config
          dangerouslySetInnerHTML={{
            __html: `
              partytown = {
                lib: "/_next/static/~partytown/",
                debug: true
              };
            `,
          }}
        />
      </Head>
      <body>
        <Main />
        <NextScript />
      </body>
    </Html>
  )
}
```

In order to modify Partytown's configuration, the following conditions must be met:

1. The `data-partytown-config` attribute must be used in order to overwrite the default configuration used by Next.js
2. Unless you decide to save Partytown's library files in a separate directory, the `lib: "/_next/static/~partytown/"` property and value must be included in the configuration object in order to let Partytown know where Next.js stores the necessary static files.

> **Note**: If you are using an [asset prefix](/docs/api-reference/next.config.js/cdn-support-with-asset-prefix.md) and would like to modify Partytown's default configuration, you must include it as part of the `lib` path.

Take a look at Partytown's [configuration options](https://partytown.builder.io/configuration) to see the full list of other properties that can be added.

### 行內指令檔

Inline scripts, or scripts not loaded from an external file, are also supported by the Script component. They can be written by placing the JavaScript within curly braces:

```jsx
<Script id="show-banner" strategy="lazyOnload">
  {`document.getElementById('banner').classList.remove('hidden')`}
</Script>
```

Or by using the `dangerouslySetInnerHTML` property:

```jsx
<Script
  id="show-banner"
  strategy="lazyOnload"
  dangerouslySetInnerHTML={{
    __html: `document.getElementById('banner').classList.remove('hidden')`,
  }}
/>
```

The `id` property is required for **inline scripts** in order for Next.js to track and optimize the script.

### 載入後執行程式碼 (`onLoad`)

> **Note: `onLoad` cannot be used with the `beforeInteractive` loading strategy. Consider using `onReady` instead.**

Some third-party scripts require users to run JavaScript code once after the script has finished loading in order to instantiate content or call a function. If you are loading a script with either `afterInteractive` or `lazyOnload` as a loading strategy, you can execute code after it has loaded using the `onLoad` property:

```jsx
import { useState } from 'react'
import Script from 'next/script'

export default function Home() {
  const [stripe, setStripe] = useState(null)

  return (
    <>
      <Script
        id="stripe-js"
        src="https://js.stripe.com/v3/"
        onLoad={() => {
          setStripe({ stripe: window.Stripe('pk_test_12345') })
        }}
      />
    </>
  )
}
```

### 掛載後執行程式碼 (`onReady`)

Some third-party scripts require users to run JavaScript code after the script has finished loading and every time the component is mounted (after a route navigation for example). You can execute code after the script's `load` event when it first loads and then after every subsequent component re-mount using the `onReady` property:

```jsx
import { useRef } from 'react'
import Script from 'next/script'

export default function Home() {
  const mapRef = useRef()
  return (
    <>
      <div ref={mapRef}></div>
      <Script
        id="google-maps"
        src="https://maps.googleapis.com/maps/api/js"
        onReady={() => {
          new google.maps.Map(mapRef.current, {
            center: { lat: -34.397, lng: 150.644 },
            zoom: 8,
          })
        }}
      />
    </>
  )
}
```

### 處理錯誤 (`onError`)

> **Note: `onError` cannot be used with the `beforeInteractive` loading strategy.**

Sometimes it is helpful to catch when a script fails to load. These errors can be handled with the `onError` property:

```jsx
import Script from 'next/script'

export default function Home() {
  return (
    <>
      <Script
        id="will-fail"
        src="https://example.com/non-existant-script.js"
        onError={(e) => {
          console.error('Script failed to load', e)
        }}
      />
    </>
  )
}
```

### Additional Attributes

There are many DOM attributes that can be assigned to a `<script>` element that are not used by the Script component, like [`nonce`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/nonce) or [custom data attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/data-*). Including any additional attributes will automatically forward it to the final, optimized `<script>` element that is outputted to the page.

```jsx
import Script from 'next/script'

export default function Home() {
  return (
    <>
      <Script
        src="https://www.google-analytics.com/analytics.js"
        id="analytics"
        nonce="XUENAJFW"
        data-test="analytics"
      />
    </>
  )
}
```
